#include <iostream> //Стандартная библиотека для ввода и вывода в консоли
using namespace std;

class Stack { // класс Stack

public: //Описание публичных методов класса Stack
    Stack(int);
    ~Stack();
    void push(int);
    int pop();
    int howMany();
    int getTopValue();
    void print(bool reverse);

private: //private данные, которые имеются во всех переменных класса Stack. Например массивы из класса RailWayStation.
    int* stackBuffer; //Массив, в котором хранится данные о цвете вагона
    int top; //Количество вагонов, находящихся в данные момент в массиве
    int size; //Общее количество вагонов вообще
};

Stack::Stack(int n) { //Конструктор класса Stack
    size = n; //Введенных размер присваивается в size
    stackBuffer = new int[size]; //Вделяется память для массива stackBuffer
    top = 0; //Изначальное количество вагонов в массиве = 0
}

Stack::~Stack() { //Деструктор. Обратное к конструктору. Если конструктор создает объект, присуждает каждому поля и выделяет для этих полей память, то Деструктор наоборот - удаляет этот объект вместе с памятью, которая была выделена для него. Запускается автоматически программой, перед самым ее завершением
    delete[] stackBuffer; //Удалить всю память выделенную под массив stackBuffer
}

int Stack::getTopValue() //Функция, которая возвращает цвет верхнего (последнего добавленного в массив) вагона
{
    return stackBuffer[top - 1];
}
int Stack::howMany() //функция которая возвращает текущее количество вагонов (top) в массиве, в котором эта функция была вызвана
{
    return top;
}

void Stack::push(int value) { //Добавление вагона в загон
    stackBuffer[top] = value; //top в момент запуска функции был равен количеству вагонов находящихся на данный момент в массиве. А ячейки идут с 0 до top-1. Поэтому новый вагон надо добавить в ячейку с индексом top, а уже потом top увеличить на 1
    top++;
}

int Stack::pop() { //возвращает верхний элемент (последний добавленный) массива, для которого эта функция была вызвана. То есть возвращаем цвет самого верхнего вагона
    top--; //То это количество вагонов на данный момент в массиве, а ячейки в массиве идут от 0 до top-1, поэтому для начала уменьшая top на 1 и потом его удаляем из этого массива. Таким образом после удаления top уже будет хранить правильное количество вагонов
    return stackBuffer[top]; //Возвращаем цвет вагона
}

void Stack::print(bool reverse) { //Reverse - параметр который мы передаем в функции печати printState. Если это конечный путь, то reverse пы передаем true и тогда он выведется с 0 до top, а для других c top до 0
    if (reverse == true) {
            for (int i = 0; i < top; i++) {
            cout << stackBuffer[i]; //Выводим элемент массива (0 или 1) по ячейкам в определнном порядке написанным в for
        }
    }
    else {
        for (int i = top - 1; i >= 0; i--) {
            cout << stackBuffer[i];
        }
    }
}

class RailWayStation //Класс RailWayStation
{
public: //Публичные данные. Их можно использовать в любом месте кода, если объявить переменную этого класса, как например sortStation в main().
    RailWayStation(int n); //Тут мы просто объявляем все публичные методы этого класса. А описываем их уже после класса
    ~RailWayStation( );
    int input();
    void sort();
    void printState();

private: //Приватные данные класса RailWayStation
    int size; //Количество вагонов (размер всех массивов)
    Stack* source, //Исходный путь (массив)
            * destination, //Итоговый путь (массив)
            * stub; //Тупиковый путь (массив)
};

RailWayStation::RailWayStation(int n) //Конструктор класса RailWayStation. Он задает все начальные значения для переменной класса, которую мы создаем через этот конструктор
{
    size = n;
    source = new Stack(size); //Выделяем память для каждого массива размера size. Все эти массивы типа данных Stack. То есть у каждого массива создаются ячейки через конструктор класса Stack. Эти ячейки - это private данные класса Stack
    destination = new Stack(size); //То есть у каждого из массивов есть по три поля: массив stackBuffer, top и size
    stub = new Stack(size);
}
RailWayStation::~RailWayStation() //Деструктор. Обратное к конструктору. Если конструктор создает объект, присуждает каждому поля и выделяет для этих полей память, то Деструктор наоборот - удаляет этот объект вместе с памятью, которая была выделена для него. Запускается автоматически программой, перед самым ее завершением
{
    delete source; //Удаление памяти выделенной для всех этих массивов
    delete destination;
    delete stub;
}
int RailWayStation::input() //Метод класса RailWayStation, для добавления введенных вагонов в массив начальной станции и проверки всех входных значений
{
    int temp, whiteCount = 0, blackCount = 0; //Временная переменная, означающая цвет вагона, который вводит пользователь; Количество введенных белых вагонов; Количество введенных черных вагонов
    for (int i = 0; i < size; i++) { //Цикл, в котором проверяются введенные пользователем данные о цвете вагонов. И считаем количество белых и черных вагонов
        cin >> temp; //Ввели цвет вагона
        if(temp == 1 || temp == 0) { //Проверили на 0 или 1. Если не 0 и не 1, тогда условие ложное и строчка выдаст ошибку
            whiteCount = whiteCount + int(temp ==
                                          0); //Переводим значение условия в число. Если temp = 1 - то int(temp == 0) = 0, иначе int(temp == 0) = 1; Таким образом мы увеличиваем колиство белых вагонов тогда, и только тогда, когда пользователь ввел белый вагон
            blackCount = blackCount + int(temp == 1); //То же самое только для афроамериканцев
            stub->push(temp); //Помещаем в тупик введенное значение
        } else {
            cout << "Ошибка. Вы ввели неверное значение для отображения цвета вагона" << endl;
            return 0;
        }
    }

    if(whiteCount == blackCount) { //Проверка на то, что введенных белых вагонов столько же, сколько и введенных черных
        while (stub->howMany()) { //Пока в тупике есть вагоны...
            source->push(stub->pop()); //Мы перекидываем их в начало
        }
        printState();
        return 1;//Вызываем функцию печати. В данном случае она выведет в консоль то, что ввел пользователь
    } else {
        cout << "Количество белых выгонов должно быть равно количеству черных" << endl;
        return 0;
    }
}
void RailWayStation::sort() //Функция сортировки вагонов
{
    while (source->howMany() || stub->howMany()) {
        if (source->howMany() && destination->getTopValue() != source->getTopValue()) {
            cout << endl << "МИМО";
            destination->push(source->pop());
        }
        else if (stub->howMany() && stub->getTopValue() != destination->getTopValue()) {
            cout << endl << "ИЗ";
            destination->push(stub->pop());
        }
        else if (!source->howMany() && stub->getTopValue() == destination->getTopValue()){
            cout << endl << "В (начало из тупика)";
            source->push(stub->pop());
        } else {
            cout << endl << "В (тупик из начала)";
            stub->push(source->pop());
        }
        printState(); //Вызов функции печати после каждого совершенного действия
    }
}
void RailWayStation::printState() //Функция печати
{
    cout << endl<<"конечный путь";
    destination->print(true); //Reverse. Каждый массив (destination, stub, source) может использовать публичные методы класса Stack, тк они объявлены в этом классе. Тут вызывается у массива функция print() написанная в Stack. У нее есть параметр reverse. Для конечного пути надо вывести наш стек с 1 добавленного в него вагона до последнего добавленного вагона. А для остальных массивов так, как оно и представляется в стеке сверху вниз,  то есть от последнего (самого верхнего) до начального (самого нижнего)
    cout << endl<<"исходный путь";
    source->print(false);
    cout << endl<<"тупик";
    stub->print(false);
    cout << endl;
}
int main()
{
    int n; //Количество вагонов. Оно должно быть больше 0, четное
    setlocale(LC_ALL, "Russian"); //Системная функция, которая говорит программе, какой язык надо использовать кроме английского. set locate - установить локализацию и в скобочках написано LC_ALL - локализовать всё, и "Russian"
    cout << "Введите общее количество вагонов n = "; //Вывод в косоль данной фразы
    cin >> n; //Ввод количества вагонов
    if(n > 0 && n % 2 == 0) {//assert - функция, у которой в скобках написано условие, которая она проверяет на ложь. Если Это условие ложно - функция завершает программу с ошибкой. Иначе - ничего не происходит. В условии написано два условия: количество больше 0 и количество четное
        cout << endl << "Введите вагоны, начиная с головы. 0 - белый , 1 - черный" << endl;
        RailWayStation *sortStation = new RailWayStation(
                n); //Объявляем переменную sortStation типа RailWayStation. Теперь в sortStation есть три параметра, которые она в себе хранит. Те же параметры, которые написаны в Классе RailWayStation в private данных. То есть тутмы запускаем конструктор класса RailWayStation. new RailWayStation(n) - создаем экземпляр класса через конструктор. То есть это частью строки мы заходим в конструктор класса RailWayStation и передаем ему значение количества вагонов
        if (sortStation->input() == 1) { //Тк у sortStation сейчас тип данных RailWayStation, то мы можем с помощью нее запускать публичные методы класса RailWayStation. И тогда все значения полученные и измененные в эти методах будут записываться в sortStation в соответствующие выделенные ему ячейки (size, destination, stub. source).
            sortStation->sort(); //То же самое
        } else cout << "Программа завершена. Повторите запуск с правильно введенными входными данными" << endl;
    } else {
        cout << "Количество вагонов должно быть четным и больше 0" << endl;
    }

    return 0;
}
